<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/hiraya-game/tiles.js - hiraya</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.7.0/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap-responsive.css">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
        hiraya
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>0.0.1</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Hiraya.Class", "classes/Hiraya.Collection", "classes/Hiraya.Emitter", "classes/Hiraya.Entity", "classes/Hiraya.Game", "classes/Hiraya.GetterSetter", "classes/Hiraya.Level", "classes/Hiraya.LevelTurnBased", "classes/Hiraya.Stat", "classes/Hiraya.Stats", "classes/Hiraya.Tile", "classes/Hiraya.Tiles", "modules/hiraya", "modules/hiraya-core", "modules/hiraya-game"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
    <h3>APIs</h3>
    <div id="sidebar">
        <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
            <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
            <li><a href="#modules" data-toggle="tab">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" placeholder="Type to filter APIs">
        </div>

        <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
            <div class="tab-pane active" id="classes">
                <ul id="api-classes" class="nav nav-list">
                    
                        <li><a href="../classes/Hiraya.Class.html">Hiraya.Class</a></li>
                    
                        <li><a href="../classes/Hiraya.Collection.html">Hiraya.Collection</a></li>
                    
                        <li><a href="../classes/Hiraya.Emitter.html">Hiraya.Emitter</a></li>
                    
                        <li><a href="../classes/Hiraya.Entity.html">Hiraya.Entity</a></li>
                    
                        <li><a href="../classes/Hiraya.Game.html">Hiraya.Game</a></li>
                    
                        <li><a href="../classes/Hiraya.GetterSetter.html">Hiraya.GetterSetter</a></li>
                    
                        <li><a href="../classes/Hiraya.Level.html">Hiraya.Level</a></li>
                    
                        <li><a href="../classes/Hiraya.LevelTurnBased.html">Hiraya.LevelTurnBased</a></li>
                    
                        <li><a href="../classes/Hiraya.Stat.html">Hiraya.Stat</a></li>
                    
                        <li><a href="../classes/Hiraya.Stats.html">Hiraya.Stats</a></li>
                    
                        <li><a href="../classes/Hiraya.Tile.html">Hiraya.Tile</a></li>
                    
                        <li><a href="../classes/Hiraya.Tiles.html">Hiraya.Tiles</a></li>
                    
                </ul>
            </div>

            <div class="tab-pane" id="modules">
                <ul id="api-modules" class="nav nav-list">
                    
                        <li><a href="../modules/hiraya.html">hiraya</a></li>
                    
                        <li><a href="../modules/hiraya-core.html">hiraya-core</a></li>
                    
                        <li><a href="../modules/hiraya-game.html">hiraya-game</a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</div>

        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <div class="page-header">
    <h1>src/hiraya-game/tiles.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
/**
 * @module hiraya
 * @submodule hiraya-game
 */

var Class = require(&#x27;../hiraya-core/class&#x27;);
var Tile = require(&#x27;./tile&#x27;);

/**
 * &#x60;Hiraya.Tiles&#x60; manages &#x60;Hiraya.Tile&#x60; instances which includes selecting neighbors and path-finding.
 *
 * @class Tiles
 * @extends Hiraya.Class
 * @namespace Hiraya
 */
var Tiles = Class.extend({
  /**
   * Total number of columns of the board.
   *
   * @property columns
   * @type {Number}
   * @default 8
   */
  columns: 8,

  /**
   * Total number of rows of the board.
   *
   * @property rows
   * @type {Number}
   * @default 8
   */
  rows: 8,

  /**
   * The matrix for the list of array for easy reference. Internal use only.
   *
   * @property _matrix
   * @type {Array}
   * @private
   */
  _matrix: null,

  /**
   * The total number of tiles.
   *
   * @property _total
   * @type {Number}
   * @private
   */
  _total: null,

  /**
   * The default Tile class to be instantiated when the board generates tiles.
   *
   * @property Tile
   * @type {Hiraya.Tile}
   * @default Hiraya.Tile
   */
  Tile: Tile,
  init: function() {
    this._generate();
  },

  /**
   * Generates the board with tiles
   *
   * @method _generate
   * @private
   */
  _generate: function() {
    this._matrix = [];
    this._total = 0;
    for(var countY = 0; countY &lt; this.rows; countY++) {
      this._matrix.push([]);
      for(var countX = 0; countX &lt; this.columns; countX++) {
        var tile = this.Tile.create();
        tile.x = countX;
        tile.y = countY;
        tile.z = this._total;
        this._matrix[countY].push(tile);
        this._total++;
      }
    }
  },

  /**
   * Retrieves a tile based on its x and y coordinates
   *
   * @method get
   * @param {Number} x
   * @param {Number} y
   * @returns {Tile}
   */
  get: function(x, y) {
    var t;
    if ((t = this._matrix[y])) {
      if ((t = t[x])) {
        return t;
      }
    }
    return t;
  },

  /**
   * Retrieves the adjacent tiles of a tile.
   *
   * @method adjacent
   * @param {Hiraya.Tile} tile
   * @returns {Array}
   */
  adjacent: function(tile) {
    var t, adjacent;
    adjacent = [];
    if ((t = this.get(tile.x - 1, tile.y - 1))) { /** NW **/
      adjacent.push(t);
    }
    if ((t = this.get(tile.x, tile.y - 1))) { /** N **/
      adjacent.push(t);
    }
    if ((t = this.get(tile.x + 1, tile.y - 1))) { /** NE **/
      adjacent.push(t);
    }
    if ((t = this.get(tile.x - 1, tile.y))) { /** E **/
      adjacent.push(t);
    }
    if ((t = this.get(tile.x + 1, tile.y))) { /** W **/
      adjacent.push(t);
    }
    if ((t = this.get(tile.x - 1, tile.y + 1))) { /** SW **/
      adjacent.push(t);
    }
    if ((t = this.get(tile.x, tile.y + 1))) { /** S **/
      adjacent.push(t);
    }
    if ((t = this.get(tile.x + 1, tile.y + 1))) { /** SE **/
      adjacent.push(t);
    }
    return adjacent;
  },

  /**
   * Find the movement cost between two tiles. Internal use only.
   *
   * @method _movementCost
   * @param {Hiraya.Tile} start
   * @param {Hiraya.Tile} end
   * @private
   * @returns {Boolean}
   */
  _movementCost: function(start, end) {
    //return end.entities.length || end.wall ? 10000 : end.val();
    return end.wall ? 10000 : end.val();
  },

  /**
   * Retrives a list of tiles by radius
   *
   * @method range
   * @param {Hiraya.Tile} tile
   * @param {Number} [radius=1]
   * @param {Boolean} [ignoreCost=false]
   * @returns {Array}
   */
  range: function(tile, radius, ignoreCost) {
    var open = [tile];
    var closed = [];
    var currTile;
    var adjacent;
    var neighbor, newCost, i, _len, tileCost;

    if (radius === undefined) {
      radius = 1;
    }

    while(open.length &gt; 0) {
      currTile = open.pop();
      closed.push(currTile);
      if (currTile.cost &lt; radius) {
        adjacent = this.adjacent(currTile);
        _len = adjacent.length;
        for(i = 0; i &lt; _len; i++) {
          neighbor = adjacent[i];
          tileCost = ignoreCost ? 1 : this._movementCost(currTile, neighbor);
          newCost = currTile.cost + tileCost;
          if (neighbor.blocked(currTile) || currTile.blocked(neighbor)) {
            continue;
          }
          if (neighbor.cost === -1 || newCost &lt; neighbor.cost) {
            neighbor.cost = newCost;
            if (open.indexOf(neighbor) === -1) {
              open.push(neighbor);
            }
          }
        }
      }
    }

    var results = [];
    for(i=0,_len=closed.length; i &lt; _len; i++) {
      currTile = closed[i];
      if (currTile.cost &lt; radius) {
        if (results.indexOf(currTile) === -1) {
          results.push(currTile);
        }
      }
      currTile.cost = -1;
    }
    return results;
  },

  /**
   * Performs an A-star pathfinding algorithm
   *
   * @method path
   * @param {Hiraya.Tile} start
   * @param {Hiraya.Tile} end
   * @returns {Array}
   */
  path: function(start, end) {
    var openList,
    closedList,
    currentNode,
    neighbors,
    neighbor,
    scoreG,
    scoreGBest,
    i,
    _len;
    openList = [start];
    closedList = [];

    while(openList.length) {
      var lowestIndex = 0;
      for(i=0,_len = openList.length; i &lt; _len; i++) {
        if (openList[i].f &lt; openList[lowestIndex].f) {
          lowestIndex = i;
        }
      }
      currentNode = openList[lowestIndex];
      // case END: The result has been found.
      if (currentNode.x === end.x &amp;&amp; currentNode.y === end.y) {
        var current = currentNode;
        var parent;
        var tiles = [];
        while (current.parent) {
          tiles.push(current);
          parent = current.parent; // capture the parent element.
          current.parent = null; // clear the tile&#x27;s parent
          current = parent; // move to the next parent
        }
        return tiles.reverse();
      }
      // case DEFAULT: Move current node to the closed list.
      openList.splice(currentNode, 1);
      closedList.push(currentNode);
      // Find the best score in the neighboring tile of the hex.
      neighbors = this.adjacent(currentNode);
      for(i=0, _len = neighbors.length; i &lt; _len; i++) {
        neighbor = neighbors[i];
        if (closedList.indexOf(neighbor) &gt; -1 ||
            neighbor.wall ||
            //neighbor.isOccupied() ||
            currentNode.blocked(neighbor) ||
            neighbor.blocked(currentNode)
           ) {
              continue;
           }
           scoreG = currentNode.g + 1;
           scoreGBest = false;
           // if it&#x27;s the first time to touch this tile.
           if(openList.indexOf(neighbor) === -1) {
             scoreGBest = true;
             neighbor.h = this.heuristic(neighbor, end);
             openList.push(neighbor);
           } else if (scoreG &lt; neighbor.g) {
             scoreGBest = true;
           }
           if (scoreGBest) {
             neighbor.parent = currentNode;
             neighbor.g = scoreG;
             neighbor.f = neighbor.g + neighbor.h;
           }
      }
    }
    return [];
  },

  /**
   * Used to calculate the heuristics for the path-finding algorithm
   *
   * @method heuristic
   * @param {Hiraya.Tile} start
   * @param {Hiraya.Tile} destination
   * @param {Number} [cost=1]
   * @returns {Number}
   */
  heuristic: function(start, destination, cost) {
    var vectorX, vectorY;
    if (cost === null) {
      cost = 1;
    }
    vectorX = Math.pow(start.x - destination.x, 2);
    vectorY = Math.pow(start.y - destination.y, 2);
    return Math.sqrt(vectorX + vectorY);
  }
});

module.exports = Tiles;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
